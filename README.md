# Real-Time Application with FreeRTOS on STM32

![Language](https://img.shields.io/badge/Language-C-blue.svg)
![RTOS](https://img.shields.io/badge/RTOS-FreeRTOS-purple.svg)
![MCU](https://img.shields.io/badge/MCU-STM32H743-red.svg)

## Project Goal

This project demonstrates a hands-on understanding of real-time operating system (RTOS) concepts by building a multi-tasking application on an STM32 Nucleo board. The goal was to go beyond a simple "blinky" and implement the core features of a real-world embedded system: independent task scheduling, inter-task communication, and shared resource management.

The entire project was developed using the professional STM32CubeIDE toolchain, demonstrating a complete workflow from hardware configuration to application-level logic.

## Key RTOS Concepts Demonstrated

This project was built incrementally to showcase a mastery of fundamental RTOS principles.

#### 1. Pre-emptive Multitasking
* **Implementation:** Two independent tasks were created, each controlling an LED at a different blinking rate (one slow, one fast).
* **Why it's important:** This demonstrates the FreeRTOS scheduler's ability to run multiple tasks concurrently. By using the `osDelay()` function, each task yields control of the CPU, allowing the scheduler to run other tasks. This pre-emptive scheduling creates the illusion of parallel execution and is the foundation of any responsive real-time system.

#### 2. Inter-Task Communication with Queues
* **Implementation:** A third task was created to monitor a user button. When the button is pressed, this "producer" task sends a message to a FreeRTOS queue. The task controlling the second LED was converted into a "consumer" task, which blocks and waits for a message on the queue before toggling the LED.
* **Why it's important:** This is the standard method for safely passing data between independent tasks. Using a queue is thread-safe and prevents issues like data corruption that could occur with shared global variables. This producer/consumer pattern is fundamental for building complex, event-driven systems where one part of the system needs to react to events generated by another.

#### 3. Shared Resource Management with Mutexes
* **Implementation:** Both LED tasks were updated to print status messages to the UART (serial port). A FreeRTOS mutex was created to protect the UART. Each task must "take" the mutex before it can print and "give" it back afterward.
* **Why it's important:** This demonstrates how to prevent a **race condition**. Without a mutex, both tasks could try to write to the UART at the exact same time, leading to interleaved and corrupted messages. The mutex acts as a lock, guaranteeing that only one task can access the shared peripheral at any given time, ensuring data integrity and clean, ungarbled output.

## Hardware & Toolchain
* **Board:** STMicroelectronics NUCLEO-H743ZI2
* **MCU Core:** ARM Cortex-M7
* **IDE:** STM32CubeIDE
* **RTOS:** FreeRTOS (with CMSIS-RTOS v2 API)

## How to Build and Run
This project was generated and built using STM32CubeIDE.
1.  Connect the Nucleo-H743ZI board to a PC.
2.  Install the necessary ST-LINK USB drivers.
3.  Open the project in STM32CubeIDE.
4.  Click the "Build" button (hammer icon) to compile the project.
5.  Click the "Run" button (green play icon) to flash the program onto the microcontroller.

#### Expected Behavior
* The green LED (LD1) blinks slowly (once every 2 seconds).
* The **yellow LED (LD2)** is initially off. It toggles its state (on/off) each time the blue user button (B1) is pressed.
* A serial terminal (e.g., PuTTY, Tera Term) connected to the ST-LINK's virtual COM port at 115200 baud will display the status messages from each task without any overlap or corruption.

